using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using UnityEditor;
using UnityEngine;

// DO NOT EDIT THIS FILE
namespace Editor {
  internal class PacksBuilder {
    private const int TOOL_VERSION = 100;
    private const string FILE_EXT = ".knsp";

    private const int SID_SIZE = 17;

    internal void Build(BuildTarget target, PacksToolCache cache) {
      if (!ValidateMeta(cache, out string error)) {
        Debug.LogError($"Kino: Unable to build sticker packs, validation error: {error}");
        return;
      }

      Debug.Log($"Kino: Build started for '{target}'");

      PacksToolCache.EnsureBuildFolder();

      foreach (var pack in cache.Packs) {
        if (!pack.SelectedToBuild) {
          continue;
        }

        BuildPackBundle(target, cache, pack);
      }
    }

    private void BuildPackBundle(BuildTarget target, PacksToolCache cache, PackMeta pack) {
      Debug.Log($"Kino: Processing pack '{pack.Name}'");

      string packFileName = $"{pack.Name}{FILE_EXT}";

      string packRootFolder = pack.GetRoot();

      var meta = pack.GetProxyMeta();
      if (meta == null) {
        Debug.LogError($"Kino: Unable to build pack '{pack.Name}', failed to create metadata");
        return;
      }

      if (string.IsNullOrWhiteSpace(meta.IconName)) {
        Debug.LogError($"Kino: Empty pack icon path for '{pack.Name}'");
        return;
      }

      meta.AuthorName = cache.Author.Name;

      if (!SaveProxyMetaToTxt(packRootFolder, meta)) {
        Debug.LogError($"Kino: Unable to build pack '{pack.Name}', failed to create metadata");
        return;
      }

      AssetDatabase.Refresh();

      var assets = new List<string> {
        Path.Combine(packRootFolder, PackMeta.PACK_META_RESERVED_NAME),
        Path.Combine(packRootFolder, $"{meta.IconName}.png")
      };

      foreach (var image in meta.Images) {
        if (string.IsNullOrWhiteSpace(image.ImageName)) {
          Debug.LogWarning($"Kino: Skipped invalid image in '{meta.Name}'");
          continue;
        }

        assets.Add(Path.Combine(packRootFolder, $"{image.ImageName}.png"));
      }

      var builds = new[] {
        new AssetBundleBuild {
          assetBundleName = packFileName,
          assetNames = assets.ToArray()
        }
      };

      BuildPipeline.BuildAssetBundles(PacksToolCache.BUILD_DIR, builds, BuildAssetBundleOptions.ForceRebuildAssetBundle, target);

      RunPostBuild(packFileName, cache, pack);
    }

    private void RunPostBuild(string fileName, PacksToolCache cache, PackMeta meta) {
      string filePath = Path.Combine(PacksToolCache.BUILD_DIR, fileName);

      if (!File.Exists(filePath)) {
        Debug.LogError($"Kino: Unable to locate sticker pack bundle at '{filePath}'");
        return;
      }

      var encryptedData = EncryptBundle(filePath, meta);
      if (encryptedData == null) {
        Debug.LogError($"Kino: Unable to encrypt sticker pack '{meta.Name}'");
        return;
      }

      using var fileStream = new FileStream(filePath, FileMode.Create);
      using var writer = new BinaryWriter(fileStream);

      writer.Write(TOOL_VERSION);
      writer.Write(meta.Version);
      writer.Write(cache.Author.SteamId);
      writer.Write(cache.Author.DiscordId);
      writer.Write(encryptedData.Length);
      writer.Write(encryptedData);
    }

    private byte[] EncryptBundle(string filePath, PackMeta meta) {
      var key = ProcessEncryptionKey(meta.EncryptionKey);

      var fileContent = File.ReadAllBytes(filePath);

      using var aesAlg = Aes.Create();
      aesAlg.Key = key.Item1;
      aesAlg.IV = key.Item2;

      using var msEncrypt = new MemoryStream();
      using (var csEncrypt = new CryptoStream(msEncrypt, aesAlg.CreateEncryptor(), CryptoStreamMode.Write)) {
        csEncrypt.Write(fileContent, 0, fileContent.Length);
        csEncrypt.FlushFinalBlock();
      }

      return msEncrypt.ToArray();
    }

    private (byte[], byte[]) ProcessEncryptionKey(string encodedKey) {
      if (string.IsNullOrWhiteSpace(encodedKey)) {
        Debug.LogError("Kino: Unable to process empty key string");
        return (null, null);
      }

      var parts = encodedKey.Split('|');
      if (parts.Length != 2) {
        Debug.LogError("Kino: Bad key string");
        return (null, null);
      }

      var key = Convert.FromBase64String(parts[0]);
      var iv = Convert.FromBase64String(parts[1]);

      return (key, iv);
    }

    private bool ValidateMeta(PacksToolCache cache, out string error) {
      error = string.Empty;

      ulong sid = cache.Author.SteamId;
      if (sid == 0 || sid.ToString().Length != SID_SIZE) {
        error = $"Invalid author SteamID: {sid}";
        return false;
      }

      if (cache.Author.DiscordId == 0) {
        error = $"Invalid author DiscordID: {cache.Author.DiscordId}";
        return false;
      }

      if (string.IsNullOrWhiteSpace(cache.Author.Name)) {
        error = $"Invalid author Name: {cache.Author.Name}";
        return false;
      }

      if (cache.Packs.Count == 0) {
        error = "Nothing to build";
        return false;
      }

      foreach (var pack in cache.Packs) {
        if (!pack.SelectedToBuild) {
          continue;
        }

        if (string.IsNullOrWhiteSpace(pack.Name)
            || string.IsNullOrWhiteSpace(pack.EncryptionKey)
            || string.IsNullOrWhiteSpace(pack.Description)) {
          error = "One of selected to build packs has empty fields";
          return false;
        }

        if (pack.Version <= 0) {
          error = $"Invalid pack version: {pack.Name} -> {pack.Version}";
          return false;
        }

        if (!pack.PackIcon) {
          error = "Pack icon is not set";
          return false;
        }
      }

      return true;
    }

    private bool SaveProxyMetaToTxt(string packRoot, PackMeta.Proxy meta) {
      if (string.IsNullOrWhiteSpace(packRoot) || meta == null) {
        return false;
      }

      try {
        string json = JsonUtility.ToJson(meta, true);

        using var stream = new FileStream(Path.Combine(packRoot, PackMeta.PACK_META_RESERVED_NAME), FileMode.Create, FileAccess.Write);
        using var writer = new StreamWriter(stream, Encoding.UTF8);
        writer.Write(json);

        return true;
      }
      catch (Exception e) {
        Debug.LogError($"Kino: Unable to save pack meta, exception: {e}");
        return false;
      }
    }
  }
}